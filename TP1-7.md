# Comparación entre la implementación basada en JPA (TP1-5) y las implementaciones sin JPA (TP1-2)

## 1. Introducción
Las prácticas TP1-2 y TP1-5 abordan el acceso a datos con enfoques contrastantes. Mientras TP1-2 emplea una estrategia manual (JDBC directo / lógica explícita de SQL y mapeo), TP1-5 incorpora la Java Persistence API (JPA) con Hibernate como proveedor. A continuación se analizan ventajas sustantivas del enfoque basado en JPA, así como posibles desventajas, desde una perspectiva académica de ingeniería de software.

## 2. Ventajas principales del uso de JPA (TP1-5)
1. Abstracción del mapeo objeto–relacional (ORM): El desarrollador trabaja con entidades (`Persona`, `Direccion`) en lugar de manejar `ResultSet`, ciclos de conversión y código repetitivo; esto reduce errores de mapeo y facilita el mantenimiento.
2. Reducción de boilerplate: Se eliminan gran parte de las sentencias repetitivas (apertura/cierre de conexiones, preparación de statements, manejo explícito de recursos) que en TP1-2 deben codificarse manualmente.
3. Portabilidad entre motores: El uso de `Dialect` y el SQL generado permite migrar entre bases (MySQL, PostgreSQL, etc.) con cambios mínimos, mientras que en el enfoque manual el SQL puede volverse específico de cada motor.
4. Gestión transaccional declarativa: Aun en un ejemplo sencillo, la API ofrece un modelo uniforme para begin/commit/rollback que puede integrarse con contenedores o Spring, reduciendo riesgos de inconsistencias.
5. Cacheo y optimizaciones internas: El primer nivel de caché (persistence context) evita lecturas redundantes de la misma entidad dentro de una transacción, mejorando rendimiento sin código adicional.
6. Evolución del modelo y schema management: Con configuraciones adecuadas (`hbm2ddl` o herramientas externas como Flyway/Liquibase), el esquema puede mantenerse sincronizado con el modelo de objetos, disminuyendo la deriva estructural.
7. Expresividad en consultas: El uso de JPQL o Criteria API permite consultas orientadas al modelo conceptual (atributos de entidades) en lugar de columnas físicas, favoreciendo refactorizaciones seguras.
8. Validaciones y anotaciones enriquecidas: Anotaciones JPA pueden combinarse con Bean Validation (e.g. `@NotNull`, `@Email`), centralizando reglas de negocio cerca del modelo.
9. Cohesión arquitectónica: El patrón repositorio/DAO se implementa con menos código imperativo y mayor uniformidad, facilitando pruebas unitarias al desacoplar lógica de negocio de los detalles de persistencia.
10. Menor probabilidad de fugas de recursos: El ciclo de vida de EntityManager abstrae cierres correctos; en JDBC manual es más frecuente olvidar cierres y provocar leaks.

## 3. Desventajas y trade-offs de JPA
1. Curva de aprendizaje y complejidad: La capa ORM introduce conceptos (contexto de persistencia, estados de entidad, proxies, cascadas) que requieren comprensión adicional.
2. Coste de rendimiento inicial (overhead): La generación de metamodelo, reflexión y SQL dinámico añade latencias marginales en aplicaciones pequeñas comparado con JDBC directo altamente optimizado.
3. Menor control fino sobre SQL: Aunque se puede usar `native queries`, el SQL generado puede no ser óptimo para casos muy específicos, requiriendo ajustes o bypass parcial del ORM.
4. Riesgo de N+1 queries: Un uso inadecuado de estrategias de fetch (`LAZY`/`EAGER`) puede degradar el rendimiento; el desarrollador debe monitorear los planes de consulta.
5. Depuración más compleja: Los errores de mapeo o sincronización del contexto pueden resultar menos transparentes que excepciones directas de JDBC.
6. Dependencia del framework: La aplicación queda acoplada a especificaciones y extensiones de un proveedor (Hibernate), lo cual puede afectar decisiones futuras si se desea un modelo de persistencia alternativo (por ejemplo, acceso reactivo o NoSQL).
7. Gestión de schema no destructiva: Configuraciones automáticas pueden dejar columnas obsoletas (como el caso de `fechaNacimiento`) si no se complementan con migraciones controladas.

## 4. Consideraciones de uso académico
En contextos educativos, JPA permite concentrar esfuerzos en modelado conceptual y patrones de diseño, acelerando iteraciones. No obstante, es pedagógicamente valioso haber transitado por la capa manual (TP1-2) para comprender cómo JPA abstrae conexiones, sentencias y transformación de datos.

## 5. Conclusión
La adopción de JPA en TP1-5 proporciona mejoras claras en mantenibilidad, abstracción y productividad, alineadas con buenas prácticas de ingeniería de software para sistemas escalables. Estos beneficios vienen acompañados de costos de complejidad y potencial overhead que deben gestionarse con un uso informado del framework, monitoreo de consultas y adopción de estrategias de migración de base de datos disciplinadas.
